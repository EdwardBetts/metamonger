#!/usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use File::Util;
use Getopt::Long qw/:config gnu_getopt no_auto_abbrev/;
use Hash::Merge::Simple qw/ merge /;
use JSON;
use Log::Contextual qw/:log :dlog set_logger with_logger/;
use Log::Contextual::SimpleLogger;
use Log::Log4perl ':easy';
use PadWalker qw/peek_my/;
use Shell::Command;
use Text::CSV_XS;

# global variables
my $VERSION = '0.20120327';
my $STORAGE_VERSION = '0';
my $STORAGE = '.metamonger';

# Getopt::Long
my $debug   = '';
my $diff    = '';
my $file    = '';
my $help    = '';
my $pretend = '';
my $restore = '';
my $save    = '';
my $verbose = '';
my $version = '';

GetOptions (
            'debug+'     => \$debug,
            'diff|d+'    => \$diff,
            'file|f=s'   => \$file,
            'help|h+'    => \$help,
            'pretend|p+' => \$pretend,
            'restore|r+' => \$restore,
            'save|s+'    => \$save,
            'verbose|v+' => \$verbose,
            'version+'   => \$version,
) || help(1);

$pretend=1;

# Set verbosity level and set up logger
if ($debug) {
	Log::Log4perl->easy_init($TRACE);
} elsif ($verbose) {
	Log::Log4perl->easy_init($DEBUG);
} else {
	Log::Log4perl->easy_init($INFO);
}
my $logger = Log::Log4perl->get_logger;
set_logger $logger;


sub get_metadata_from_storage {
	my ($file_metadata_ref) = @_;
	#TODO catch and handle non-existing file
	touch $STORAGE unless -e $STORAGE;
	open(my $storage_fh, "<", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};

	# Don't read file as JSON, merge, or check storage version if the file is empty
	unless (eof $storage_fh) {
		# Merge new data into existing hashref
		# relaxed mode allows us to read the trailing comma
		$file_metadata_ref = merge $file_metadata_ref, from_json(do {local $/; <$storage_fh>}, {relaxed => 1});
		unless ($file_metadata_ref->{config}{storage_version} == $STORAGE_VERSION) {
			log_fatal { "Wrong storage version: need '$STORAGE_VERSION', got '$file_metadata_ref->{config}{storage_version}'" };
			die;
		}
	}

	return $file_metadata_ref;
}

sub get_file_metadata_from_fs {
	my ($files_ref, $file_metadata_ref) = @_;
	foreach my $file (@$files_ref) {
		# TODO allow user to store specific metadata, only
		(undef,                          # device number
		 undef,                          # inode number
		 $file_metadata_ref->{metadata}{$file}{mode},
		 undef,                          # number of (hard) links
		 undef,                          # numeric user ID
		 undef,                          # numeric group ID
		 undef,                          # device identifier
		 undef,                          # total size
		 $file_metadata_ref->{metadata}{$file}{atime},
		 $file_metadata_ref->{metadata}{$file}{mtime},
		 $file_metadata_ref->{metadata}{$file}{ctime},
		 undef,                          # preferred block size
		 undef,                          # blocks allocated
		) = lstat($file) or log_fatal {"Could not stat '$file': $!"};
	}
	log_trace { '%file_metadata: ' . Dumper $file_metadata_ref };
	return $file_metadata_ref;
}

sub help {
	#TODO Switch to POD
	#TODO use Getopt::Long qw/:config auto_help/
	my ($ret)=@_;
	print "usage: $0 <args> <glob>

	--debug      Print debug messages
	--diff|d     Diff between stored and live metadata
	--file|f     Specify storage file
	--help|h     Display this help
	--pretend|p  Pretend to do something; print results only
	--verbose|v  Print verbose messages
	--version    Display version information
";
	exit $ret;
}

sub set_defaults {
	my ($file_metadata_ref) = @_;
	$file_metadata_ref->{config}{program} = 'metastore';
	$file_metadata_ref->{config}{storage_version} = 0;
	$file_metadata_ref->{config}{strict_json} = 0;
	#TODO 'used metadata'
	$file_metadata_ref->{config}{tracked_metadata}{ctime} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{atime} = 1;
	$file_metadata_ref->{config}{tracked_metadata}{mtime} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{mode} = 0;
	return $file_metadata_ref;
}

sub version {
	print "$0 version $VERSION\n";
	exit;
}

sub write_metadata_to_storage {
	my ($file_metadata_ref) = @_;
	my $json = to_json($file_metadata_ref, {canonical => 1, utf8 => 1});
	$json =~ s/"metadata":{/"metadata":{\n/;
	$json =~ s/},/},\n/g;
	if ($file_metadata_ref->{config}{strict_json} == 0) {
		$json =~ s/}}}/},\n}}\n/g;
	} else {
		$json =~ s/}}}/}\n}}\n/g;
	}

	open(my $storage_fh, ">", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};
	print $storage_fh $json;
	close $storage_fh;

	print $json;
}

sub main {

	# Avoid doing extra work if we are running cheap code
	if ($help) {
		help(0);
	} elsif ($version) {
		version;
	}

	# Match ARGV to files and directories
	my @matches;
	if (@ARGV) {
		@matches = map glob($_), @ARGV;
		log_error { "$0: no matches found for '@ARGV'"} unless grep -e $_, @matches;
	} else {
		# Default to '*' if we don't have any files to operate one.
		# Using '.' here would pull in dotfiles via list_dir()
		@matches = map glob($_), '*';
	}
	log_trace { "globbing matches:\n" . Dumper @matches };

	# Recurse through directories, add files directly
	my @files;
	foreach my $match (@matches) {
		my $file_util = File::Util->new();
		@files = map $file_util->list_dir($_, '--recurse'), $match if -d $match;
		push(@files, $match) if -f $match;
	}

	# It's likely that we will need this data so let's read it
	my %file_metadata;
	my $file_metadata_ref = \%file_metadata;

	#TODO set defaults
	$file_metadata_ref = set_defaults($file_metadata_ref);
	#TODO read global config
	#TODO read user config
	#TODO read potential command lines options

	$file_metadata_ref = get_metadata_from_storage($file_metadata_ref);

	if      (!$diff && !$restore &&  $save) {
		# save live data to file
		$file_metadata_ref = get_file_metadata_from_fs(\@files, $file_metadata_ref);
		write_metadata_to_storage($file_metadata_ref);
	} elsif (!$diff &&  $restore && !$save) {
		# restore data from file to live
		#TODO
	} elsif ( $diff && !$restore && !$save) {
		# diff file against live data
		#TODO
	} else {
		log_trace {'Did not enter any other routine; printing help and exiting'};
		help(0);
	}


#	log_trace {"All variables\n" . Dumper peek_my(0) };
#	log_trace {'trace'};
#	log_debug {'debug'};
#	log_info  {'info'};
#	log_warn  {'warn'};
#	log_error {'error'};
#	log_fatal {'fatal'};

}

main;
