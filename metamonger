#!/usr/bin/perl

use strict;
use warnings;
use v5.10;

use Config::Simple;
use Data::Dumper;
use File::Util;
use Getopt::Long qw/:config gnu_getopt no_auto_abbrev/;
use Hash::Diff qw/diff/;
use Hash::Merge::Simple qw/merge/;
use JSON;
use Log::Contextual qw/:log :dlog set_logger with_logger/;
use Log::Contextual::SimpleLogger;
use Log::Log4perl ':easy';
use PadWalker qw/peek_my/;
use Shell::Command;

# global variables
my $VERSION = '0.20130824';
my $STORAGE_VERSION = '0';
my $STORAGE = '.metamonger';

# Allowed function references; required by `use strict`
my %DIFF_ACTIONS = (
	'print_metadata'       => \&print_metadata,
	'set_metadata_on_file' => \&set_metadata_on_file,
	'print_diff'          => \&print_diff,
);

# Getopt::Long
my $opt_config  = '';
my $opt_debug   = '';
my $opt_diff    = '';
my $opt_file    = '';
my $opt_help    = '';
my $opt_no_act  = '';
my $opt_restore = '';
my $opt_save    = '';
my $opt_verbose = '';
my $opt_version = '';

GetOptions (
	'config|c=s' => \$opt_config,
	'debug'      => \$opt_debug,
	'diff|d'     => \$opt_diff,
	'file|f=s'   => \$opt_file,
	'help|h'     => \$opt_help,
	'no-act|n'   => \$opt_no_act,
	'restore|r'  => \$opt_restore,
	'save|s'     => \$opt_save,
	'verbose|v'  => \$opt_verbose,
	'version'    => \$opt_version,
) || help(1);

# Set verbosity level and set up logger
if ($opt_debug) {
	Log::Log4perl->easy_init($TRACE);
} elsif ($opt_verbose) {
	Log::Log4perl->easy_init($DEBUG);
} else {
	Log::Log4perl->easy_init($INFO);
}
my $logger = Log::Log4perl->get_logger;
set_logger $logger;

sub diff_data {
	my ($fs_ref, $file_metadata_ref) = @_;

	print "filename - metadata - old ===> new\n";
	diff_hashes ($fs_ref, $file_metadata_ref, $DIFF_ACTIONS{print_diff});
}

sub diff_hashes {
	my ($a, $b, $execute_sub) = @_;
	my $error_count = 0;
	my %diff_hash = %{ diff( $a, $b ) };
	for my $file_name (keys $diff_hash{'metadata'}) {
		next unless defined $diff_hash{'metadata'}{$file_name};

		$error_count += &$execute_sub($file_name, \%{$a->{'metadata'}{$file_name}}, \%{$b->{'metadata'}{$file_name}}, \%{$diff_hash{'metadata'}{$file_name}});
	}
}

sub print_diff {
	my ($file_name, $fs_ref, $file_metadata_ref, $diff_ref) = @_;

	return if !keys $file_metadata_ref;

	foreach my $metadata ( keys $diff_ref ) {
		next if !$file_metadata_ref->{$metadata};

		print "file: $file_name: $metadata: $file_metadata_ref->{$metadata} ==> $diff_ref->{$metadata}\n";
	}

}

sub get_metadata_from_storage {
	my ($file_metadata_ref) = @_;
	touch $STORAGE unless -e $STORAGE;
	open(my $storage_fh, "<", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};

	# Stop here if the read file if empty to avoid useless errors
	unless (eof $storage_fh) {
		# Merge new data into existing hashref
		# relaxed mode allows us to read the trailing comma
		$file_metadata_ref = merge $file_metadata_ref, from_json(do {local $/; <$storage_fh>}, {relaxed => 1});

		unless ($file_metadata_ref->{config}{storage_version} == $STORAGE_VERSION) {
			close $storage_fh;
			log_fatal { "Wrong storage version: need '$STORAGE_VERSION', got '$file_metadata_ref->{config}{storage_version}'" };
			die;
		}
	}

	close $storage_fh;
	return $file_metadata_ref;
}

sub get_file_metadata_from_fs {
	my ($files_ref, $file_metadata_ref) = @_;
	foreach my $file (@$files_ref) {
		(undef,                          # device number
		 undef,                          # inode number
		 $file_metadata_ref->{metadata}{$file}{mode},
		 undef,                          # number of (hard) links
		 $file_metadata_ref->{metadata}{$file}{uid},
		 $file_metadata_ref->{metadata}{$file}{gid},
		 undef,                          # device identifier
		 undef,                          # total size
		 $file_metadata_ref->{metadata}{$file}{atime},
		 $file_metadata_ref->{metadata}{$file}{mtime},
		 undef,                          # ctime; can not be set on Unix
		 undef,                          # preferred block size
		 undef,                          # blocks allocated
		) = lstat($file) or log_fatal {"Could not stat '$file': $!"};

		$file_metadata_ref->{metadata}{$file}{mode} = sprintf ("%04o", $file_metadata_ref->{metadata}{$file}{mode} & 07777);

		# Don't store metadata types unless told to,
		# but if {config} isn't there skip this part and
		# assume we want the full FS data.
		next if (!$file_metadata_ref->{config});

		for my $metadata_type (keys $file_metadata_ref->{config}{tracked_metadata}) {
			delete $file_metadata_ref->{metadata}{$file}{$metadata_type} unless $file_metadata_ref->{config}{tracked_metadata}{$metadata_type};
		}
	}
	log_trace { '%file_metadata: ' . Dumper $file_metadata_ref };
	return $file_metadata_ref;
}

sub help {
	#TODO Switch to POD
	#TODO use Getopt::Long qw/:config auto_help/
	my ($ret)=@_;
	print "usage: $0 <args> <glob>

	--config     Sets config file. Defaults to ~/.config/metamonger.
	--debug      Print debug messages
	--diff|d     Diff between stored and live metadata
	--file|f     Specify storage file
	--help|h     Display this help
	--no-act|n   Do not act; print results only
	--restore|r  Restore metadata to file system
	--save|s     Write metadata to file
	--verbose|v  Print verbose messages
	--version    Display version information
";
	exit $ret;
}

sub load_config {
	my ($file_metadata_ref, $config_file) = @_;

	return $file_metadata_ref unless ($config_file);
	return $file_metadata_ref unless -e $config_file;

	my %cfg;
	Config::Simple->import_from($config_file, \%cfg);

	foreach my $option (keys $file_metadata_ref->{config}) {
		if ($option eq 'tracked_metadata') {
			foreach my $metadata (keys $file_metadata_ref->{config}{tracked_metadata}) {
				$file_metadata_ref->{config}{tracked_metadata}{$metadata} = $cfg{"tracked_metadata.$metadata"} if defined $cfg{"tracked_metadata.$metadata"};
			}
		} else {
			$file_metadata_ref->{config}{$option} = $cfg{"default.$option"} if defined $cfg{"default.$option"};
		}
	}

	return $file_metadata_ref;
}


sub set_defaults {
	my ($file_metadata_ref) = @_;
	$file_metadata_ref->{config}{program} = 'metamonger';
	$file_metadata_ref->{config}{storage_version} = 0;
	$file_metadata_ref->{config}{strict_json} = 1;
	$file_metadata_ref->{config}{tracked_metadata}{uid} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{gid} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{atime} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{mtime} = 1;
	$file_metadata_ref->{config}{tracked_metadata}{mode} = 0;
	return $file_metadata_ref;
}

sub set_metadata_on_file {
	my ($file_name, $file_metadata_ref, $fs_ref, $diff_ref) = @_;
	my $error_count = 0;
	my $written_atime = 0;
	my $written_mtime = 0;

	for my $metadata_name (keys $diff_ref) {
		my $metadata_value = $diff_ref->{$metadata_name};

		if ($metadata_name eq 'mtime' && !$written_atime) {
			my $atime = $diff_ref->{'atime'} || $file_metadata_ref->{'atime'} || $fs_ref->{'atime'} || -1;
			log_trace{'Stored mtime, read atime from FS: ' . $atime};

			utime($atime, $metadata_value, $file_name) or do {
				warn "$0: couldn't set atime on '$file_name': $!";
				$error_count++;
			};
			$written_mtime = 1;
		}

		if ($metadata_name eq 'atime' && !$written_mtime) {
			my $mtime = $diff_ref->{'mtime'} || $file_metadata_ref->{'mtime'} || $fs_ref->{'mtime'} || -1;
			log_trace{'Stored atime, read mtime from FS: ' . $mtime};

			utime($metadata_value, $mtime, $file_name) or do {
				warn "$0: couldn't set atime on '$file_name': $!";
				$error_count++;
			};
			$written_atime = 1;
		}

		if ($metadata_name eq 'mode') {
			chmod $metadata_value, $file_name;
		}
	}
	return $error_count;
}

sub version {
	print "$0 version $VERSION\n";
	exit;
}

sub write_metadata_to_fs {
	my ($metadata_fs_ref, $file_metadata_ref) = @_;
	log_trace { '%file_metadata: ' . Dumper $file_metadata_ref };
	my $error_count = 0;
	#TODO better names
	my %file_metadata_config;
	$file_metadata_config{'config'} = delete $file_metadata_ref->{'config'};
	$error_count += diff_hashes($file_metadata_ref, $metadata_fs_ref, $DIFF_ACTIONS{'set_metadata_on_file'});



	# TODO utimes for ?time
	# TODO chown for ?id
	# TODO chmod for ?mode
	#      read as integer, not string
	#      check if we are root and error out if we are not

	return $error_count;
}

sub write_metadata_to_storage {
	my ($file_metadata_ref) = @_;
	my $json = to_json($file_metadata_ref, {canonical => 1});
	$json =~ s/"metadata":{/"metadata":{\n/;
	$json =~ s/},/},\n/g;
	if ($file_metadata_ref->{config}{strict_json} == 0) {
		$json =~ s/}}}/},\n}}\n/g;
	} else {
		$json =~ s/}}}/}\n}}\n/g;
	}

	open(my $storage_fh, ">", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};
	print $storage_fh $json;
	close $storage_fh;

	log_trace{"metadata stored in '$STORAGE':\n".$json};
}

sub main {

	# Avoid doing extra work if we are running cheap code
	if ($opt_help) {
		help(0);
	} elsif ($opt_version) {
		version;
	}

	# Initialize variables
	my $error_count = 0;

	# Match ARGV to files and directories
	my @matches;
	if (@ARGV) {
		@matches = map glob($_), @ARGV;
		log_error { "$0: no matches found for '@ARGV'"} unless grep -e $_, @matches;
	} else {
		# Default to '*' if we don't have any files to operate one.
		# Using '.' here would pull in dotfiles via list_dir()
		@matches = map glob($_), '*';
	}
	log_trace { "globbing matches:\n" . Dumper @matches };

	# Recurse through directories, add files directly
	my @files;
	foreach my $match (@matches) {
		my $file_util = File::Util->new();

		push (@files, map $file_util->list_dir($_, '--recurse'), $match) if -d $match;
		push(@files, $match) if -f $match;
	}

	# It's likely that we will need this data so let's read it
	my %file_metadata;
	my $file_metadata_ref = \%file_metadata;

	$file_metadata_ref = set_defaults($file_metadata_ref);

	# If the user provided a config file, it should override the normal config files..
	if ($opt_config) {
		if (!-e $opt_config) {
			log_fatal { "$opt_config doesn't exist!" };
			exit 1;
		}

		$file_metadata_ref = load_config ($file_metadata_ref, $opt_config);
	} else {
		$file_metadata_ref = load_config ($file_metadata_ref, $ENV{"HOME"} . '/.config/metamonger');
		$file_metadata_ref = load_config ($file_metadata_ref, '/etc/metamonger/config');
	}
	# ..but the values stored in the actual file should still take precedence
	$file_metadata_ref = get_metadata_from_storage($file_metadata_ref);
	# only directly changed options should trump that
	#TODO read potential command lines options

	if      (!$opt_diff && !$opt_restore &&  $opt_save) {
		# save live data to file
		$file_metadata_ref = get_file_metadata_from_fs(\@files, $file_metadata_ref);
		write_metadata_to_storage($file_metadata_ref);
	} elsif (!$opt_diff &&  $opt_restore && !$opt_save) {
		# restore data from file to live
		my %metadata_fs;
		my $metadata_fs_ref = \%metadata_fs;
		$metadata_fs_ref = get_file_metadata_from_fs(\@files, $metadata_fs_ref);
		$error_count += write_metadata_to_fs($metadata_fs_ref, $file_metadata_ref);
	} elsif ( $opt_diff && !$opt_restore && !$opt_save) {
		# diff file against live data
		my %metadata_fs;

		my $metadata_fs_ref = \%metadata_fs;
		$metadata_fs_ref = get_file_metadata_from_fs(\@files, $metadata_fs_ref);

		diff_data ( $metadata_fs_ref, $file_metadata_ref );
	} else {
		log_trace {'Did not enter any other routine; printing help and exiting'};
		help(0);
	}

	log_error { "There were a total of $error_count non-fatal errors"} if $error_count;

#	log_trace {"All variables\n" . Dumper peek_my(0) };
#	log_trace {'trace'};
#	log_debug {'debug'};
#	log_info  {'info'};
#	log_warn  {'warn'};
#	log_error {'error'};
#	log_fatal {'fatal'};

}

main;
