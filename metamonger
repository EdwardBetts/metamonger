#!/usr/bin/perl

use strict;
use warnings;
use v5.10;

use Data::Dumper;
use File::Util;
use Getopt::Long qw/:config gnu_getopt no_auto_abbrev/;
use Hash::Diff qw/diff/;
use Hash::Merge::Simple qw/merge/;
use JSON;
use Log::Contextual qw/:log :dlog set_logger with_logger/;
use Log::Contextual::SimpleLogger;
use Log::Log4perl ':easy';
use PadWalker qw/peek_my/;
use Shell::Command;

# global variables
my $VERSION = '0.20130627';
my $STORAGE_VERSION = '0';
my $STORAGE = '.metamonger';

# Allowed function references; required by `use strict`
my %DIFF_ACTIONS = (
	'print_metadata'       => \&print_metadata,
	'set_metadata_on_file' => \&set_metadata_on_file,
);

# Getopt::Long
my $opt_debug   = '';
my $opt_diff    = '';
my $opt_file    = '';
my $opt_help    = '';
my $opt_no_act  = '';
my $opt_restore = '';
my $opt_save    = '';
my $opt_verbose = '';
my $opt_version = '';

GetOptions (
	'debug'     => \$opt_debug,
	'diff|d'    => \$opt_diff,
	'file|f=s'  => \$opt_file,
	'help|h'    => \$opt_help,
	'no-act|n'  => \$opt_no_act,
	'restore|r' => \$opt_restore,
	'save|s'    => \$opt_save,
	'verbose|v' => \$opt_verbose,
	'version'   => \$opt_version,
) || help(1);

# Set verbosity level and set up logger
if ($opt_debug) {
	Log::Log4perl->easy_init($TRACE);
} elsif ($opt_verbose) {
	Log::Log4perl->easy_init($DEBUG);
} else {
	Log::Log4perl->easy_init($INFO);
}
my $logger = Log::Log4perl->get_logger;
set_logger $logger;


sub diff_hashes {
	my ($fs_ref, $file_metadata_ref, $execute_sub) = @_;
	my %diff_hash = %{ diff( $file_metadata_ref, $fs_ref ) };
	for my $file_name (keys $diff_hash{'metadata'}) {
		next unless defined $diff_hash{'metadata'}{$file_name};

		&$execute_sub($file_name, \%{$fs_ref->{'metadata'}{$file_name}}, \%{$file_metadata_ref->{'metadata'}{$file_name}}, \%{$diff_hash{'metadata'}{$file_name}});
    }
}

sub get_metadata_from_storage {
	my ($file_metadata_ref) = @_;
	touch $STORAGE unless -e $STORAGE;
	open(my $storage_fh, "<", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};

	# Stop here if the read file if empty to avoid useless errors
	unless (eof $storage_fh) {
		# Merge new data into existing hashref
		# relaxed mode allows us to read the trailing comma
		$file_metadata_ref = merge $file_metadata_ref, from_json(do {local $/; <$storage_fh>}, {relaxed => 1});
		unless ($file_metadata_ref->{config}{storage_version} == $STORAGE_VERSION) {
			log_fatal { "Wrong storage version: need '$STORAGE_VERSION', got '$file_metadata_ref->{config}{storage_version}'" };
			die;
		}
	}

	return $file_metadata_ref;
}

sub get_file_metadata_from_fs {
	my ($files_ref, $file_metadata_ref) = @_;
	foreach my $file (@$files_ref) {
		(undef,                          # device number
		 undef,                          # inode number
		 $file_metadata_ref->{metadata}{$file}{mode},
		 undef,                          # number of (hard) links
		 $file_metadata_ref->{metadata}{$file}{uid},
		 $file_metadata_ref->{metadata}{$file}{gid},
		 undef,                          # device identifier
		 undef,                          # total size
		 $file_metadata_ref->{metadata}{$file}{atime},
		 $file_metadata_ref->{metadata}{$file}{mtime},
		 undef,                          # ctime; can not be set on Unix
		 undef,                          # preferred block size
		 undef,                          # blocks allocated
		) = lstat($file) or log_fatal {"Could not stat '$file': $!"};

		$file_metadata_ref->{metadata}{$file}{mode} = sprintf ("%04o", $file_metadata_ref->{metadata}{$file}{mode} & 07777);

		# Don't store metadata types unless told to,
		# but if {config} isn't there skip this part and
		# assume we want the full FS data.
		next if (!$file_metadata_ref->{config});

		for my $metadata_type (keys $file_metadata_ref->{config}{tracked_metadata}) {
			delete $file_metadata_ref->{metadata}{$file}{$metadata_type} unless $file_metadata_ref->{config}{tracked_metadata}{$metadata_type};
		}
	}
	log_trace { '%file_metadata: ' . Dumper $file_metadata_ref };
	return $file_metadata_ref;
}

sub help {
	#TODO Switch to POD
	#TODO use Getopt::Long qw/:config auto_help/
	my ($ret)=@_;
	print "usage: $0 <args> <glob>

	--debug      Print debug messages
	--diff|d     Diff between stored and live metadata
	--file|f     Specify storage file
	--help|h     Display this help
	--no-act|n   Do not act; print results only
	--restore|r  Restore metadata to file system
	--write|s    Write metadata to file
	--verbose|v  Print verbose messages
	--version    Display version information
";
	exit $ret;
}

sub set_defaults {
	my ($file_metadata_ref) = @_;
	$file_metadata_ref->{config}{program} = 'metamonger';
	$file_metadata_ref->{config}{storage_version} = 0;
	$file_metadata_ref->{config}{strict_json} = 1;
	$file_metadata_ref->{config}{tracked_metadata}{uid} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{gid} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{atime} = 0;
	$file_metadata_ref->{config}{tracked_metadata}{mtime} = 1;
	$file_metadata_ref->{config}{tracked_metadata}{mode} = 0;
	return $file_metadata_ref;
}

sub set_metadata_on_file {
	my ($file_name, $fs_ref, $file_metadata_ref, $diff_ref) = @_;
	my $written_atime = 0;
	my $written_mtime = 0;

	for my $metadata_name (keys $diff_ref) {
		my $metadata_value = $diff_ref->{$metadata_name};

		if ($metadata_name eq 'mtime' && !$written_atime) {
			my $atime = $diff_ref->{'atime'} || $file_metadata_ref->{'atime'} || $fs_ref->{'atime'} || -1;
			print 'having mtime- atime is: ' . $atime . "\n" ;

			utime($atime, $metadata_value, $file_name) or warn "$0: couldn't set atime $!";
			$written_mtime = 1;
		}

		if ($metadata_name eq 'atime' && !$written_mtime) {
			my $mtime = $diff_ref->{'mtime'} || $file_metadata_ref->{'mtime'} || $fs_ref->{'mtime'} || -1;
			print 'having atime - mtime is: ' . $mtime ;

			utime($metadata_value, $mtime, $file_name) or warn "$0: couldn't set atime $!";
			$written_atime = 1;
		}
	}
}

sub version {
	print "$0 version $VERSION\n";
	exit;
}

sub write_metadata_to_fs {
	my ($metadata_fs_ref, $file_metadata_ref) = @_;
	log_trace { '%file_metadata: ' . Dumper $file_metadata_ref };
	#TODO better names
	my %file_metadata_config;
	$file_metadata_config{'config'} = delete $file_metadata_ref->{'config'};
	diff_hashes($metadata_fs_ref, $file_metadata_ref, $DIFF_ACTIONS{'set_metadata_on_file'});



	# TODO utimes for ?time
	# TODO chown for ?id
	# TODO chmod for ?mode
	#      read as integer, not string
	#      check if we are root and error out if we are not
}

sub write_metadata_to_storage {
	my ($file_metadata_ref) = @_;
	my $json = to_json($file_metadata_ref, {canonical => 1});
	$json =~ s/"metadata":{/"metadata":{\n/;
	$json =~ s/},/},\n/g;
	if ($file_metadata_ref->{config}{strict_json} == 0) {
		$json =~ s/}}}/},\n}}\n/g;
	} else {
		$json =~ s/}}}/}\n}}\n/g;
	}

	open(my $storage_fh, ">", $STORAGE) or do {
		log_fatal { "Can not open '$STORAGE': $!" };
		die;
	};
	print $storage_fh $json;
	close $storage_fh;

	log_trace{"metadata stored in '$STORAGE':\n".$json};
}

sub main {

	# Avoid doing extra work if we are running cheap code
	if ($opt_help) {
		help(0);
	} elsif ($opt_version) {
		version;
	}

	# Match ARGV to files and directories
	my @matches;
	if (@ARGV) {
		@matches = map glob($_), @ARGV;
		log_error { "$0: no matches found for '@ARGV'"} unless grep -e $_, @matches;
	} else {
		# Default to '*' if we don't have any files to operate one.
		# Using '.' here would pull in dotfiles via list_dir()
		@matches = map glob($_), '*';
	}
	log_trace { "globbing matches:\n" . Dumper @matches };

	# Recurse through directories, add files directly
	my @files;
	foreach my $match (@matches) {
		my $file_util = File::Util->new();
		@files = map $file_util->list_dir($_, '--recurse'), $match if -d $match;
		push(@files, $match) if -f $match;
	}

	# It's likely that we will need this data so let's read it
	my %file_metadata;
	my $file_metadata_ref = \%file_metadata;

	$file_metadata_ref = set_defaults($file_metadata_ref);
	#TODO read global config
	#TODO read user config
	#TODO read potential command lines options

	$file_metadata_ref = get_metadata_from_storage($file_metadata_ref);

	if      (!$opt_diff && !$opt_restore &&  $opt_save) {
		# save live data to file
		$file_metadata_ref = get_file_metadata_from_fs(\@files, $file_metadata_ref);
		write_metadata_to_storage($file_metadata_ref);
	} elsif (!$opt_diff &&  $opt_restore && !$opt_save) {
		# restore data from file to live
		my %metadata_fs;
		my $metadata_fs_ref = \%metadata_fs;
		$metadata_fs_ref = get_file_metadata_from_fs(\@files, $metadata_fs_ref);
		write_metadata_to_fs($metadata_fs_ref, $file_metadata_ref);
	} elsif ( $opt_diff && !$opt_restore && !$opt_save) {
		# diff file against live data
		#TODO
	} else {
		log_trace {'Did not enter any other routine; printing help and exiting'};
		help(0);
	}


#	log_trace {"All variables\n" . Dumper peek_my(0) };
#	log_trace {'trace'};
#	log_debug {'debug'};
#	log_info  {'info'};
#	log_warn  {'warn'};
#	log_error {'error'};
#	log_fatal {'fatal'};

}

main;
